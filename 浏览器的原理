### 浏览器底层原理

#### 1. 浏览器的本地存储

浏览器的本地存储主要分为cookie，webStorage（localStorage 和 sessionStorage）和indexDB

##### 1.1 cookie

Cookie 最开始被设计出来其实并不是来做本地存储的，而是为了弥补HTTP在状态管理上的不足。HTTP协议是一个无状态协议，客户端向服务器发请求，服务器返回响应，故事就这样结束了，但是下次 发请求如何让服务端知道客户端是谁呢?这时候就产生了cookie。

Cookie 本质上就是浏览器里面存储的一个很小的文本文件，内部以键值对的方式来存储(在chrome开发 者面板的 Application 这一栏可以看到)。向同一个域名下发送请求，都会携带相同的 Cookie，服务器 拿到 Cookie 进行解析，便能拿到客户端的状态。

Cookie 的作用很好理解，就是用来做状态存储的，但它也是有诸多致命的缺陷的:

- 容量缺陷。cookie只有4kb，只能存储少量信息
- 性能缺陷，cookie紧跟域名，不管域名下某一个地址是不是需要cookie，请求都会带上完整的cookie，随着请求增多，就会造成巨大的资源浪费。
- 安全缺陷，cookie是以文本的形式存储在服务器和浏览器的传递中，很容易被非法获取，然后篡改，在cookie有效期内重新发送是很危险的，在httpOnly为false的情况是，cookie是能通过js脚本获取的。

##### 1.2 localStorage

localStorage有一点跟Cookie一样，就是针对一个域名，即在同一个域名下，会存储相同的一段 localStorage。

不过它相对Cookie还是有相当多的区别的:

- 容量。localStorage 的容量上限为**5M**，相比于 Cookie 的 4K 大大增加。当然这个 5M 是针对一个 域名的，因此对于一个域名是持久存储的。 

- 只存在客户端，默认不参与与服务端的通信。这样就很好地避免了 Cookie 带来的**性能问题**和**安全 问题**。

- 接口封装。通过 localStorage 暴露在全局，并通过它的 setItem 和 getItem 等方法进行操作，非常方便。

  操作如下：

  ```js
  let obj = { name: "sanyuan", age: 18 };
  localStorage.setItem("name", "sanyuan");
  localStorage.setItem("info", JSON.stringify(obj));
  ```

  接着进入相同的域名时就能拿到相应的值:

  ```js
  let name = localStorage.getItem("name");
  let info = JSON.parse(localStorage.getItem("info"));
  ```

  从这里可以看出， localStorage 其实存储的都是字符串，如果是存储对象需要调用 JSON 的 stringify 方法，并且用 JSON.parse 来解析成对象。

**应用场景**

利用 localStorage 的较大容量和持久特性，可以利用 localStorage 存储一些内容稳定的资源，比如 官网的 logo ，存储 Base64 格式的图片资源，因此利用 localStorage

##### 1.3 sessionStorage

sessionStorage 以下方面和 localStorage 一致:

- 容量。容量上限也为 5M。
- 只存在客户端，默认不参与与服务端的通信。
- 接口封装。除了 sessionStorage 名字有所变化，存储方式、操作方式均和 localStorage 一样。

但 sessionStorage 和 localStorage 有一个本质的区别，那就是前者只是会话级别的存储，并不是持久化存储。会话结束，也就是页面关闭，这部分 sessionStorage 就不复存在了。

**应用场景**

1)可以用它对表单信息进行维护，将表单信息存储在里面，可以保证页面即使刷新也不会让之前的表单 信息丢失。

2)可以用它存储本次浏览记录。如果关闭页面后不需要这些记录，用 sessionStorage 就再合适不过 了。事实上微博就采取了这样的存储方式。

##### 1.4 IndexedDB

indexedDB是运行在浏览器中的非关系型数据库，本质上是数据库，理论上容量是没有上限的。

它除了拥有数据库本身的特征，比如支持事务，存储二进制数据，还有这样一些特性需要格外注意:

- 键值对存储。内部采用 对象仓库 存放数据，在这个对象仓库中数据采用**键值对**的方式来存储。 
- 异步操作。数据库的读写属于 I/O 操作, 浏览器中对异步 I/O 提供了支持。 
- 受同源策略限制，即无法访问跨域的数据库。

**总结**：

(1) 并不适合存储，而且存在非常多的缺陷。

(2) webStorage包括localStorage 和sessionStorage , 默认不会参与和服务器的通信。

(3) IndexedDB 为运行在浏览器上的非关系型数据库，为大型数据的存储提供了接口。

#### 2. 从URL输入到页面渲染发生了什么（网络）

假设我输入了百度的地址：

```js
https://www.baidu.com/
```

**网络请求**

**(1)构建请求**：浏览器回构建请求行

```js
// 请求方法是GET，路径为根路径，HTTP协议版本为1.1 
GET / HTTP/1.1
```

**(2)查找强缓存**

先检查强缓存，如果命中直接使用，否则进入下一步。

**(3)DNS解析**

由于我们输入的是域名，而数据包是通过IP地址传送给对方的，因为我们要得到域名对应的IP地址。这个过程需要依赖一个服务系统，这个系统将域名和IP做映射，这个系统就是DNS（域名系统），得到IP的过程就是DNS解析。

浏览器是提供了DNS缓存的功能。如果一个域名被解析过，那么会把这个解析的结果缓存下来，下次处理直接走缓存，而不需要进行解析了。如果不指定端口，默认是采用对应的IP的80端口。

**(4)建立TCP连接**

Chrome 在同一个域名下要求同时最多只能有 6 个 TCP 连接，超过 6 个的话剩下的请 求就得等待。

建立TCP经历了下面三个阶段：

- 三次握手建立连接
- 数据传输，接收方收到数据包后必须要发送ACK确认，如果发送端没有收到这个确认包，就判定为数据丢失，重新发送该数据包。当然，发送的过程中还有一 个优化策略，就是把大的数据包拆成一个个小包 ，依次传输到接收方，接收方按照这个小包的顺序把它们组装成完整数据包。
- 数据传输完成，断开连接，四次挥手。

**(5)发送** **HTTP** **请求**

TCP连接建立完成，浏览器可以和服务器开始通信了，开始发送http请求，浏览器发http请求要携带三样东西：请求行，请求头和请求体。

首先浏览器回向服务器发送请求行，在第一步已经构建完成。同时带上请求头，比如Cache-Control、If-Modified-Since、If-None-Match都由可能被放入请求头中作为缓存的标识信息。当然了还有一些其他的属性，列举如下:

```http
Accept:
text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,image/apng,*/*; q=0.8,application/signed-exchange;v=b3
Accept-Encoding: gzip, deflate, br
Accept-Language: zh-CN,zh;q=0.9
Cache-Control: no-cache
Connection: keep-alive
Cookie: /* 省略cookie信息 */
Host: www.baidu.com
Pragma: no-cache
Upgrade-Insecure-Requests: 1
User-Agent: Mozilla/5.0 (iPhone; CPU iPhone OS 11_0 like Mac OS X) 
AppleWebKit/604.1.38 (KHTML, like Gecko) Version/11.0 Mobile/15A372 Safari/604.1
```

最后是请求体，请求体只有在POST方法下才存在。

**网络响应**

请求到达服务器，服务器进行处理，最后要发数据发送给浏览器，也就是网络响应。跟请求部分类似，网络响应有三个部分：响应行**、**响应头和响应体。

响应行：

```http
HTTP/1.1 200 OK
```

响应头包含了服务器及其返回数据的一些信息, 服务器生成数据的时间、返回的数据类型以及对即将写入的Cookie信息。

```http
Cache-Control: no-cache
Connection: keep-alive
Content-Encoding: gzip
Content-Type: text/html;charset=utf-8
Date: Wed, 04 Dec 2019 12:29:13 GMT
Server: apache
Set-Cookie:
rsv_i=f9a0SIItKqzv7kqgAAgphbGyRts3RwTg%2FLyU3Y5Eh5LwyfOOrAsvdezbay0QqkDqFZ0DfQXb
y4wXKT8Au8O7ZT9UuMsBq2k; path=/; domain=.baidu.com
```

响应结束后，要判断connection字段，如果是keep-alive，表示建立了持久连接，TCP会一直保持，之后请求同一站点的 资源回复用该连接，否则就断开TCP连接，请求相应结束。

**总结**

![image-20220329164733628](/Users/Mr.Meow/Library/Application Support/typora-user-images/image-20220329164733628.png)

#### 3. 从URL输入到页面渲染发生了什么（解析算法）

完成网络请求，如果响应头中Content-Type 的值是 text/html ，那么接下来就是浏览器解析和渲染的工作了。主要分为以下几个步骤：

- 构建DOM树
- 样式计算
- 生成布局树

##### 3.1 构建DOM树

浏览器是无法理解html字符串的，因此将这一系列字节流转换为有意义的方便操作的数据结构，dom树。本质上，dom树就是以document为根节点的多叉树。

HTML5 规范详细地介绍了解析算法。这个算法分为两个阶段:标记化。 建树。

**标记化算法**

这个算法输入为 HTML文本 ，输出为 HTML标记 ，也成为**标记生成器**。其中运用**有限自动状态机**来完成。 即在当前状态下，接收一个或多个字符，就会更新到下一个状态。通过一个简单的例子来演示一下 标记化的过程

```html
<html>
  <body>
    Hello sanyuan
  </body>
</html>
```

遇到 < , 状态为**标记打开**。
接收 [a-z] 的字符，会进入**标记名称状态**。
这个状态一直保持，直到遇到 > ，表示标记名称记录完成，这时候变为**数据状态**。 

接下来遇到 body 标签做同样的处理。

这个时候 html 和 body 的标记都记录好了。
现在来到 <body> 中的 > ，进入**数据状态**，之后保持这样状态接收后面的字符**hello sanyuan**。 

接着接收 </body> 中的 < ，回到**标记打开**, 接收下一个 / 后，这时候会创建一个 end tag 的token。 随后进入**标记名称状态**, 遇到 > 回到**数据状态**。
接着以同样的样式处理 </body> 。

标记生成器会把每个标记的信息发送给**建树器**。**建树器**接收到相应的标记时，会**创建对应的** **DOM** **对象**。创建这个 DOM对象 后会做两件事情: 将 加入 DOM 树中; 将对应标记压入存放开放(与 闭合标签 意思对应)元素的栈中。

接收到标记生成器传来的 html 标签，这时候状态变为**before html状态**。同时创建一个HTMLHtmlElement 的 DOM 元素, 将其加到 document 根对象上，并进行压栈操作。 接着状态自动变为**before head**, 此时从标记生成器那边传来 body ，表示并没有 head , 这时候**建树器**会自动创建一个**HTMLHeadElement**并将其加入到 DOM树 中。 现在进入到**in head**状态, 然后直接跳到**after head**。

现在**标记生成器**传来了 body 标记，创建**HTMLBodyElement**, 插入到 DOM 树中，同时压入开放标记栈。

接着状态变为**in body**，然后来接收后面一系列的字符: **Hello sanyuan**。接收到第一个字符的时候，会 创建一个**Text**节点并把字符插入其中，然后把**Text**节点插入到 DOM 树中 body元素 的下面。随着不断 接收后面的字符，这些字符会附在**Text**节点上。

现在，**标记生成器**传过来一个 body 的结束标记，进入到**after body**状态。 **标记生成器**最后传过来一个 html 的结束标记, 进入到**after after body**的状态，表示解析过程到此结束。

##### 3.2 样式计算

css样式一般有三种：link标签引入，style标签中的样式，元素内嵌样式。

**（1）格式化样式表**

浏览器是无法直接识别css文本的。因此渲染引擎收到css文本后，第一件事就是讲起转化为一个结构化的对象，styleSheets。在浏览器控制台能够通过 document.styleSheets 来查看这个最终的结构。

**(2)  标准化样式属性**

有一些 CSS 样式的数值并不容易被渲染引擎所理解，因此需要在计算样式之前将它们标准化，如 em -\>px,red->#ff0000,bold->700等等。

**(3)  计算每个节点的具体样式**

进行过格式化和标准化了，接下来就是计算具体细节了，主要是继承和层叠。每个字节点都会默认继承父节点的样式属性，如果父节点没有找到，就采用浏览器的默认样式。

层叠的规则就是，最后的样式取决的各个属性共同作用的效果，最后所有的样式都会被挂在到window.getComputedStyle中，也就是可以通过js来获取最后的样式

##### 3.3 布局树

现在已经生成了DOM树和DOM样式，接下来就是通过浏览器的布局系统确认元素的位置，生成布局树。大致过程如下：

遍历生成的DOM树节点，把他们添加到布局树中，计算布局树节点的坐标位置

这棵布局树包含可见元素，对于head标签和设置了display为none的元素不会被放进去。

**小结**

<img src="/Users/Mr.Meow/Library/Application Support/typora-user-images/image-20220329171349617.png" alt="image-20220329171349617" style="zoom:50%;" />

#### 4. 说一说从输入URL到页面呈现发生了什么?(渲染过程)

渲染就分为下面几个步骤：

- 图层树
- 绘制列表
- 生成图块并栅格化
- 显示器显示内容

##### 4.1 建图层树

浏览器构建完布局树后还会对特定节点分层，构建图层树。默认节点的涂层是属于父节点的图层（合成层），有两种情况下回提升为一个单独的合成层。

**(1)显式合成** 下面是 显式合成 的情况:

一、 拥有**层叠上下文**的节点。 层叠上下文也基本上是有一些特定的CSS属性创建的，一般有以下情况:

- HTML根元素本身就具有层叠上下文。 普通元素设置**position** 不为static并且**设置了**z-index属性**，会产生层叠上下文。 元素的 **opacity** 值不是 1
- 元素的 **transform** 值不是 none
- 元素的 **filter** 值不是 none
- 元素的 **isolation** 值是isolate **will-change**指定的属性值为上面任意一个。

二、需要**剪裁**的地方。
 比如一个div，你只给他设置 100 * 100 像素的大小，而你在里面放了非常多的文字，那么超出的文字部分就需要被剪裁。当然如果出现了滚动条，那么滚动条会被单独提升为一个图层。

**(2)隐式合成** 简单来说就是 层叠等级低 的节点被提升为单独的图层之后，那么 所有层叠等级比它高的节点**都会**成为一个单独的图层。

这个隐式合成其实隐藏着巨大的风险，如果在一个大型应用中，当一个 z-index 比较低的元素被提升为 单独图层之后，层叠在它上面的的元素统统都会被提升为单独的图层，可能会增加上千个图层，大大增 加内存的压力，甚至直接让页面崩溃。这就是**层爆炸**的原理。值得注意的是，当需要 repaint 时，只需要 repaint 本身，而不会影响到其他的层。

##### 4.2 生成绘制列表

接下来渲染引擎会将图层的绘制拆分成一个个绘制指令，比如先画背景，在画边框等等，将这些指令按顺序组合成一个待绘制的列表，相当于给后面的绘制操作做了一个计划表。

##### 4.3 生成图块和位图

在渲染进程中，绘制操作是由专门的线程来完成的，叫合成线程。绘制列表准备好后，渲染进程的主线程会给合成线程发送commit消息，把列表里的人物交给合成线程。

如果一口气把所有都画出来是非常浪费性能的，因此合成线程会将图层图层分块，通常是 256 * 256 或者 512 * 512 这个规格。这样可以大大加速页面的首屏展示。

后面的图块数据要进入GPU内存，可是浏览器内存传到GPU内存是很费时间的，所以chrome有一个策略，首次合成图块只采用低分辨率的图片，首屏展示的是低分辨率的图片，这个时候继续合成，等正常的图块的内容都绘制结束后再替换低分辨率的图块。这也是chrome底层优化首屏加载的手段。

渲染进程中维护了一个栅格化线程池，专门负责吧图块转化为位图。然后合成线程会选择视口附近的图块，把它交给栅格化线程池生成位图。

生成位图的过程实际上都会使用GPU加速，生成的位图最后发送给合成线程。

##### 4.4 显示器显示内容

栅格化操作完成后，合成线程会生成一个绘制指令，即"DrawQuad"，并发送给浏览器进程。浏览器进程中的 viz组件 接收到这个命令，根据这个命令，把页面内容绘制到内存，生成了页面，然后把这部分内存发送给显卡。

显卡的成像原理：

无论是 PC 显示器还是手机屏幕，都有一个固定的刷新频率，一般是 60 HZ，即 60 帧，也就是一秒更新 60 张图片，一张图片停留的时间约为 16.7 ms。而每次更新的图片都来自显卡的**前缓冲区**。而显卡接收 到浏览器进程传来的页面后，会合成相应的图像，并将图像保存到**后缓冲区**，然后系统自动将 前缓冲区 和 后缓冲区 对换位置，如此循环更新。

**总结**

![image-20220329182127233](/Users/Mr.Meow/Library/Application Support/typora-user-images/image-20220329182127233.png)

#### 5. 重绘和回流

根据上面，我们知道渲染的流程为

![image-20220411232608845](/Users/Mr.Meow/Library/Application Support/typora-user-images/image-20220411232608845.png)

##### 5.1 回流（重排）

当我们对DOM结构的修改引发DOM几何变化时，会发生回流。具体的有以下这些操作：

1. DOM元素的几何属性变化，常见的有width，height，padding，margin，left，top，border等
2. DOM节点发生增减或者移动
3. 读写`offset`,`scroll`,`client`族属性的时候，浏览器为了获取这些值，需要进行回流
4. 调用window.getComputedStyle方法。

根据上面渲染的流水线，我们可以看出如果触发了回流，那么就会重新渲染DOM树，然后后面的流程包括主线之外的任务会全部走一遍。也就是解析和合成的过程重新走了一遍，开销非常大。

![image-20220411233430945](/Users/Mr.Meow/Library/Application Support/typora-user-images/image-20220411233430945.png)

##### 5.2 重绘

当DOM的样式发生改变，且没有影响几何属性的时候会导致重绘

由于没有几何属性的变化，因此元素的位置信息不需要更新，从而省去的布局的过程，也就是跳过生成布局树和建图层的阶段，直接生成绘制列表，然后继续分块，生成位图等后面一系列的操作。

![image-20220411233630235](./images/image-20220411233630235.png)

因此，我们可以看到重绘不一定重排，但是重排一定会重绘

